// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  doctor: (where?: DoctorWhereInput) => Promise<boolean>;
  patient: (where?: PatientWhereInput) => Promise<boolean>;
  survey: (where?: SurveyWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  doctor: (where: DoctorWhereUniqueInput) => DoctorNullablePromise;
  doctors: (args?: {
    where?: DoctorWhereInput;
    orderBy?: DoctorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Doctor>;
  doctorsConnection: (args?: {
    where?: DoctorWhereInput;
    orderBy?: DoctorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DoctorConnectionPromise;
  patient: (where: PatientWhereUniqueInput) => PatientNullablePromise;
  patients: (args?: {
    where?: PatientWhereInput;
    orderBy?: PatientOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Patient>;
  patientsConnection: (args?: {
    where?: PatientWhereInput;
    orderBy?: PatientOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PatientConnectionPromise;
  survey: (where: SurveyWhereUniqueInput) => SurveyNullablePromise;
  surveys: (args?: {
    where?: SurveyWhereInput;
    orderBy?: SurveyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Survey>;
  surveysConnection: (args?: {
    where?: SurveyWhereInput;
    orderBy?: SurveyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SurveyConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createDoctor: (data: DoctorCreateInput) => DoctorPromise;
  updateDoctor: (args: {
    data: DoctorUpdateInput;
    where: DoctorWhereUniqueInput;
  }) => DoctorPromise;
  updateManyDoctors: (args: {
    data: DoctorUpdateManyMutationInput;
    where?: DoctorWhereInput;
  }) => BatchPayloadPromise;
  upsertDoctor: (args: {
    where: DoctorWhereUniqueInput;
    create: DoctorCreateInput;
    update: DoctorUpdateInput;
  }) => DoctorPromise;
  deleteDoctor: (where: DoctorWhereUniqueInput) => DoctorPromise;
  deleteManyDoctors: (where?: DoctorWhereInput) => BatchPayloadPromise;
  createPatient: (data: PatientCreateInput) => PatientPromise;
  updatePatient: (args: {
    data: PatientUpdateInput;
    where: PatientWhereUniqueInput;
  }) => PatientPromise;
  updateManyPatients: (args: {
    data: PatientUpdateManyMutationInput;
    where?: PatientWhereInput;
  }) => BatchPayloadPromise;
  upsertPatient: (args: {
    where: PatientWhereUniqueInput;
    create: PatientCreateInput;
    update: PatientUpdateInput;
  }) => PatientPromise;
  deletePatient: (where: PatientWhereUniqueInput) => PatientPromise;
  deleteManyPatients: (where?: PatientWhereInput) => BatchPayloadPromise;
  createSurvey: (data: SurveyCreateInput) => SurveyPromise;
  updateSurvey: (args: {
    data: SurveyUpdateInput;
    where: SurveyWhereUniqueInput;
  }) => SurveyPromise;
  updateManySurveys: (args: {
    data: SurveyUpdateManyMutationInput;
    where?: SurveyWhereInput;
  }) => BatchPayloadPromise;
  upsertSurvey: (args: {
    where: SurveyWhereUniqueInput;
    create: SurveyCreateInput;
    update: SurveyUpdateInput;
  }) => SurveyPromise;
  deleteSurvey: (where: SurveyWhereUniqueInput) => SurveyPromise;
  deleteManySurveys: (where?: SurveyWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  doctor: (
    where?: DoctorSubscriptionWhereInput
  ) => DoctorSubscriptionPayloadSubscription;
  patient: (
    where?: PatientSubscriptionWhereInput
  ) => PatientSubscriptionPayloadSubscription;
  survey: (
    where?: SurveySubscriptionWhereInput
  ) => SurveySubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type PatientOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "birthday_ASC"
  | "birthday_DESC"
  | "name_ASC"
  | "name_DESC";

export type DoctorOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "speciality_ASC"
  | "speciality_DESC"
  | "name_ASC"
  | "name_DESC";

export type SurveyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "published_ASC"
  | "published_DESC"
  | "answered_ASC"
  | "answered_DESC"
  | "title_ASC"
  | "title_DESC"
  | "content_ASC"
  | "content_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type DoctorWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export interface PatientWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  birthday?: Maybe<String>;
  birthday_not?: Maybe<String>;
  birthday_in?: Maybe<String[] | String>;
  birthday_not_in?: Maybe<String[] | String>;
  birthday_lt?: Maybe<String>;
  birthday_lte?: Maybe<String>;
  birthday_gt?: Maybe<String>;
  birthday_gte?: Maybe<String>;
  birthday_contains?: Maybe<String>;
  birthday_not_contains?: Maybe<String>;
  birthday_starts_with?: Maybe<String>;
  birthday_not_starts_with?: Maybe<String>;
  birthday_ends_with?: Maybe<String>;
  birthday_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  doctors_every?: Maybe<DoctorWhereInput>;
  doctors_some?: Maybe<DoctorWhereInput>;
  doctors_none?: Maybe<DoctorWhereInput>;
  surveys_every?: Maybe<SurveyWhereInput>;
  surveys_some?: Maybe<SurveyWhereInput>;
  surveys_none?: Maybe<SurveyWhereInput>;
  AND?: Maybe<PatientWhereInput[] | PatientWhereInput>;
  OR?: Maybe<PatientWhereInput[] | PatientWhereInput>;
  NOT?: Maybe<PatientWhereInput[] | PatientWhereInput>;
}

export interface DoctorWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  speciality?: Maybe<String>;
  speciality_not?: Maybe<String>;
  speciality_in?: Maybe<String[] | String>;
  speciality_not_in?: Maybe<String[] | String>;
  speciality_lt?: Maybe<String>;
  speciality_lte?: Maybe<String>;
  speciality_gt?: Maybe<String>;
  speciality_gte?: Maybe<String>;
  speciality_contains?: Maybe<String>;
  speciality_not_contains?: Maybe<String>;
  speciality_starts_with?: Maybe<String>;
  speciality_not_starts_with?: Maybe<String>;
  speciality_ends_with?: Maybe<String>;
  speciality_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  patients_every?: Maybe<PatientWhereInput>;
  patients_some?: Maybe<PatientWhereInput>;
  patients_none?: Maybe<PatientWhereInput>;
  surveys_every?: Maybe<SurveyWhereInput>;
  surveys_some?: Maybe<SurveyWhereInput>;
  surveys_none?: Maybe<SurveyWhereInput>;
  AND?: Maybe<DoctorWhereInput[] | DoctorWhereInput>;
  OR?: Maybe<DoctorWhereInput[] | DoctorWhereInput>;
  NOT?: Maybe<DoctorWhereInput[] | DoctorWhereInput>;
}

export interface SurveyWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  published?: Maybe<Boolean>;
  published_not?: Maybe<Boolean>;
  answered?: Maybe<Boolean>;
  answered_not?: Maybe<Boolean>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  submitter?: Maybe<DoctorWhereInput>;
  patient?: Maybe<PatientWhereInput>;
  AND?: Maybe<SurveyWhereInput[] | SurveyWhereInput>;
  OR?: Maybe<SurveyWhereInput[] | SurveyWhereInput>;
  NOT?: Maybe<SurveyWhereInput[] | SurveyWhereInput>;
}

export type PatientWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export type SurveyWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface DoctorCreateInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  speciality: String;
  name: String;
  patients?: Maybe<PatientCreateManyWithoutDoctorsInput>;
  surveys?: Maybe<SurveyCreateManyWithoutSubmitterInput>;
}

export interface PatientCreateManyWithoutDoctorsInput {
  create?: Maybe<
    PatientCreateWithoutDoctorsInput[] | PatientCreateWithoutDoctorsInput
  >;
  connect?: Maybe<PatientWhereUniqueInput[] | PatientWhereUniqueInput>;
}

export interface PatientCreateWithoutDoctorsInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  birthday: String;
  name: String;
  surveys?: Maybe<SurveyCreateManyWithoutPatientInput>;
}

export interface SurveyCreateManyWithoutPatientInput {
  create?: Maybe<
    SurveyCreateWithoutPatientInput[] | SurveyCreateWithoutPatientInput
  >;
  connect?: Maybe<SurveyWhereUniqueInput[] | SurveyWhereUniqueInput>;
}

export interface SurveyCreateWithoutPatientInput {
  id?: Maybe<ID_Input>;
  published?: Maybe<Boolean>;
  answered?: Maybe<Boolean>;
  title: String;
  content: String;
  submitter: DoctorCreateOneWithoutSurveysInput;
}

export interface DoctorCreateOneWithoutSurveysInput {
  create?: Maybe<DoctorCreateWithoutSurveysInput>;
  connect?: Maybe<DoctorWhereUniqueInput>;
}

export interface DoctorCreateWithoutSurveysInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  speciality: String;
  name: String;
  patients?: Maybe<PatientCreateManyWithoutDoctorsInput>;
}

export interface SurveyCreateManyWithoutSubmitterInput {
  create?: Maybe<
    SurveyCreateWithoutSubmitterInput[] | SurveyCreateWithoutSubmitterInput
  >;
  connect?: Maybe<SurveyWhereUniqueInput[] | SurveyWhereUniqueInput>;
}

export interface SurveyCreateWithoutSubmitterInput {
  id?: Maybe<ID_Input>;
  published?: Maybe<Boolean>;
  answered?: Maybe<Boolean>;
  title: String;
  content: String;
  patient: PatientCreateOneWithoutSurveysInput;
}

export interface PatientCreateOneWithoutSurveysInput {
  create?: Maybe<PatientCreateWithoutSurveysInput>;
  connect?: Maybe<PatientWhereUniqueInput>;
}

export interface PatientCreateWithoutSurveysInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  birthday: String;
  name: String;
  doctors?: Maybe<DoctorCreateManyWithoutPatientsInput>;
}

export interface DoctorCreateManyWithoutPatientsInput {
  create?: Maybe<
    DoctorCreateWithoutPatientsInput[] | DoctorCreateWithoutPatientsInput
  >;
  connect?: Maybe<DoctorWhereUniqueInput[] | DoctorWhereUniqueInput>;
}

export interface DoctorCreateWithoutPatientsInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  speciality: String;
  name: String;
  surveys?: Maybe<SurveyCreateManyWithoutSubmitterInput>;
}

export interface DoctorUpdateInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  speciality?: Maybe<String>;
  name?: Maybe<String>;
  patients?: Maybe<PatientUpdateManyWithoutDoctorsInput>;
  surveys?: Maybe<SurveyUpdateManyWithoutSubmitterInput>;
}

export interface PatientUpdateManyWithoutDoctorsInput {
  create?: Maybe<
    PatientCreateWithoutDoctorsInput[] | PatientCreateWithoutDoctorsInput
  >;
  delete?: Maybe<PatientWhereUniqueInput[] | PatientWhereUniqueInput>;
  connect?: Maybe<PatientWhereUniqueInput[] | PatientWhereUniqueInput>;
  set?: Maybe<PatientWhereUniqueInput[] | PatientWhereUniqueInput>;
  disconnect?: Maybe<PatientWhereUniqueInput[] | PatientWhereUniqueInput>;
  update?: Maybe<
    | PatientUpdateWithWhereUniqueWithoutDoctorsInput[]
    | PatientUpdateWithWhereUniqueWithoutDoctorsInput
  >;
  upsert?: Maybe<
    | PatientUpsertWithWhereUniqueWithoutDoctorsInput[]
    | PatientUpsertWithWhereUniqueWithoutDoctorsInput
  >;
  deleteMany?: Maybe<PatientScalarWhereInput[] | PatientScalarWhereInput>;
  updateMany?: Maybe<
    | PatientUpdateManyWithWhereNestedInput[]
    | PatientUpdateManyWithWhereNestedInput
  >;
}

export interface PatientUpdateWithWhereUniqueWithoutDoctorsInput {
  where: PatientWhereUniqueInput;
  data: PatientUpdateWithoutDoctorsDataInput;
}

export interface PatientUpdateWithoutDoctorsDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  birthday?: Maybe<String>;
  name?: Maybe<String>;
  surveys?: Maybe<SurveyUpdateManyWithoutPatientInput>;
}

export interface SurveyUpdateManyWithoutPatientInput {
  create?: Maybe<
    SurveyCreateWithoutPatientInput[] | SurveyCreateWithoutPatientInput
  >;
  delete?: Maybe<SurveyWhereUniqueInput[] | SurveyWhereUniqueInput>;
  connect?: Maybe<SurveyWhereUniqueInput[] | SurveyWhereUniqueInput>;
  set?: Maybe<SurveyWhereUniqueInput[] | SurveyWhereUniqueInput>;
  disconnect?: Maybe<SurveyWhereUniqueInput[] | SurveyWhereUniqueInput>;
  update?: Maybe<
    | SurveyUpdateWithWhereUniqueWithoutPatientInput[]
    | SurveyUpdateWithWhereUniqueWithoutPatientInput
  >;
  upsert?: Maybe<
    | SurveyUpsertWithWhereUniqueWithoutPatientInput[]
    | SurveyUpsertWithWhereUniqueWithoutPatientInput
  >;
  deleteMany?: Maybe<SurveyScalarWhereInput[] | SurveyScalarWhereInput>;
  updateMany?: Maybe<
    | SurveyUpdateManyWithWhereNestedInput[]
    | SurveyUpdateManyWithWhereNestedInput
  >;
}

export interface SurveyUpdateWithWhereUniqueWithoutPatientInput {
  where: SurveyWhereUniqueInput;
  data: SurveyUpdateWithoutPatientDataInput;
}

export interface SurveyUpdateWithoutPatientDataInput {
  published?: Maybe<Boolean>;
  answered?: Maybe<Boolean>;
  title?: Maybe<String>;
  content?: Maybe<String>;
  submitter?: Maybe<DoctorUpdateOneRequiredWithoutSurveysInput>;
}

export interface DoctorUpdateOneRequiredWithoutSurveysInput {
  create?: Maybe<DoctorCreateWithoutSurveysInput>;
  update?: Maybe<DoctorUpdateWithoutSurveysDataInput>;
  upsert?: Maybe<DoctorUpsertWithoutSurveysInput>;
  connect?: Maybe<DoctorWhereUniqueInput>;
}

export interface DoctorUpdateWithoutSurveysDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  speciality?: Maybe<String>;
  name?: Maybe<String>;
  patients?: Maybe<PatientUpdateManyWithoutDoctorsInput>;
}

export interface DoctorUpsertWithoutSurveysInput {
  update: DoctorUpdateWithoutSurveysDataInput;
  create: DoctorCreateWithoutSurveysInput;
}

export interface SurveyUpsertWithWhereUniqueWithoutPatientInput {
  where: SurveyWhereUniqueInput;
  update: SurveyUpdateWithoutPatientDataInput;
  create: SurveyCreateWithoutPatientInput;
}

export interface SurveyScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  published?: Maybe<Boolean>;
  published_not?: Maybe<Boolean>;
  answered?: Maybe<Boolean>;
  answered_not?: Maybe<Boolean>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  AND?: Maybe<SurveyScalarWhereInput[] | SurveyScalarWhereInput>;
  OR?: Maybe<SurveyScalarWhereInput[] | SurveyScalarWhereInput>;
  NOT?: Maybe<SurveyScalarWhereInput[] | SurveyScalarWhereInput>;
}

export interface SurveyUpdateManyWithWhereNestedInput {
  where: SurveyScalarWhereInput;
  data: SurveyUpdateManyDataInput;
}

export interface SurveyUpdateManyDataInput {
  published?: Maybe<Boolean>;
  answered?: Maybe<Boolean>;
  title?: Maybe<String>;
  content?: Maybe<String>;
}

export interface PatientUpsertWithWhereUniqueWithoutDoctorsInput {
  where: PatientWhereUniqueInput;
  update: PatientUpdateWithoutDoctorsDataInput;
  create: PatientCreateWithoutDoctorsInput;
}

export interface PatientScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  birthday?: Maybe<String>;
  birthday_not?: Maybe<String>;
  birthday_in?: Maybe<String[] | String>;
  birthday_not_in?: Maybe<String[] | String>;
  birthday_lt?: Maybe<String>;
  birthday_lte?: Maybe<String>;
  birthday_gt?: Maybe<String>;
  birthday_gte?: Maybe<String>;
  birthday_contains?: Maybe<String>;
  birthday_not_contains?: Maybe<String>;
  birthday_starts_with?: Maybe<String>;
  birthday_not_starts_with?: Maybe<String>;
  birthday_ends_with?: Maybe<String>;
  birthday_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<PatientScalarWhereInput[] | PatientScalarWhereInput>;
  OR?: Maybe<PatientScalarWhereInput[] | PatientScalarWhereInput>;
  NOT?: Maybe<PatientScalarWhereInput[] | PatientScalarWhereInput>;
}

export interface PatientUpdateManyWithWhereNestedInput {
  where: PatientScalarWhereInput;
  data: PatientUpdateManyDataInput;
}

export interface PatientUpdateManyDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  birthday?: Maybe<String>;
  name?: Maybe<String>;
}

export interface SurveyUpdateManyWithoutSubmitterInput {
  create?: Maybe<
    SurveyCreateWithoutSubmitterInput[] | SurveyCreateWithoutSubmitterInput
  >;
  delete?: Maybe<SurveyWhereUniqueInput[] | SurveyWhereUniqueInput>;
  connect?: Maybe<SurveyWhereUniqueInput[] | SurveyWhereUniqueInput>;
  set?: Maybe<SurveyWhereUniqueInput[] | SurveyWhereUniqueInput>;
  disconnect?: Maybe<SurveyWhereUniqueInput[] | SurveyWhereUniqueInput>;
  update?: Maybe<
    | SurveyUpdateWithWhereUniqueWithoutSubmitterInput[]
    | SurveyUpdateWithWhereUniqueWithoutSubmitterInput
  >;
  upsert?: Maybe<
    | SurveyUpsertWithWhereUniqueWithoutSubmitterInput[]
    | SurveyUpsertWithWhereUniqueWithoutSubmitterInput
  >;
  deleteMany?: Maybe<SurveyScalarWhereInput[] | SurveyScalarWhereInput>;
  updateMany?: Maybe<
    | SurveyUpdateManyWithWhereNestedInput[]
    | SurveyUpdateManyWithWhereNestedInput
  >;
}

export interface SurveyUpdateWithWhereUniqueWithoutSubmitterInput {
  where: SurveyWhereUniqueInput;
  data: SurveyUpdateWithoutSubmitterDataInput;
}

export interface SurveyUpdateWithoutSubmitterDataInput {
  published?: Maybe<Boolean>;
  answered?: Maybe<Boolean>;
  title?: Maybe<String>;
  content?: Maybe<String>;
  patient?: Maybe<PatientUpdateOneRequiredWithoutSurveysInput>;
}

export interface PatientUpdateOneRequiredWithoutSurveysInput {
  create?: Maybe<PatientCreateWithoutSurveysInput>;
  update?: Maybe<PatientUpdateWithoutSurveysDataInput>;
  upsert?: Maybe<PatientUpsertWithoutSurveysInput>;
  connect?: Maybe<PatientWhereUniqueInput>;
}

export interface PatientUpdateWithoutSurveysDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  birthday?: Maybe<String>;
  name?: Maybe<String>;
  doctors?: Maybe<DoctorUpdateManyWithoutPatientsInput>;
}

export interface DoctorUpdateManyWithoutPatientsInput {
  create?: Maybe<
    DoctorCreateWithoutPatientsInput[] | DoctorCreateWithoutPatientsInput
  >;
  delete?: Maybe<DoctorWhereUniqueInput[] | DoctorWhereUniqueInput>;
  connect?: Maybe<DoctorWhereUniqueInput[] | DoctorWhereUniqueInput>;
  set?: Maybe<DoctorWhereUniqueInput[] | DoctorWhereUniqueInput>;
  disconnect?: Maybe<DoctorWhereUniqueInput[] | DoctorWhereUniqueInput>;
  update?: Maybe<
    | DoctorUpdateWithWhereUniqueWithoutPatientsInput[]
    | DoctorUpdateWithWhereUniqueWithoutPatientsInput
  >;
  upsert?: Maybe<
    | DoctorUpsertWithWhereUniqueWithoutPatientsInput[]
    | DoctorUpsertWithWhereUniqueWithoutPatientsInput
  >;
  deleteMany?: Maybe<DoctorScalarWhereInput[] | DoctorScalarWhereInput>;
  updateMany?: Maybe<
    | DoctorUpdateManyWithWhereNestedInput[]
    | DoctorUpdateManyWithWhereNestedInput
  >;
}

export interface DoctorUpdateWithWhereUniqueWithoutPatientsInput {
  where: DoctorWhereUniqueInput;
  data: DoctorUpdateWithoutPatientsDataInput;
}

export interface DoctorUpdateWithoutPatientsDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  speciality?: Maybe<String>;
  name?: Maybe<String>;
  surveys?: Maybe<SurveyUpdateManyWithoutSubmitterInput>;
}

export interface DoctorUpsertWithWhereUniqueWithoutPatientsInput {
  where: DoctorWhereUniqueInput;
  update: DoctorUpdateWithoutPatientsDataInput;
  create: DoctorCreateWithoutPatientsInput;
}

export interface DoctorScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  speciality?: Maybe<String>;
  speciality_not?: Maybe<String>;
  speciality_in?: Maybe<String[] | String>;
  speciality_not_in?: Maybe<String[] | String>;
  speciality_lt?: Maybe<String>;
  speciality_lte?: Maybe<String>;
  speciality_gt?: Maybe<String>;
  speciality_gte?: Maybe<String>;
  speciality_contains?: Maybe<String>;
  speciality_not_contains?: Maybe<String>;
  speciality_starts_with?: Maybe<String>;
  speciality_not_starts_with?: Maybe<String>;
  speciality_ends_with?: Maybe<String>;
  speciality_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<DoctorScalarWhereInput[] | DoctorScalarWhereInput>;
  OR?: Maybe<DoctorScalarWhereInput[] | DoctorScalarWhereInput>;
  NOT?: Maybe<DoctorScalarWhereInput[] | DoctorScalarWhereInput>;
}

export interface DoctorUpdateManyWithWhereNestedInput {
  where: DoctorScalarWhereInput;
  data: DoctorUpdateManyDataInput;
}

export interface DoctorUpdateManyDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  speciality?: Maybe<String>;
  name?: Maybe<String>;
}

export interface PatientUpsertWithoutSurveysInput {
  update: PatientUpdateWithoutSurveysDataInput;
  create: PatientCreateWithoutSurveysInput;
}

export interface SurveyUpsertWithWhereUniqueWithoutSubmitterInput {
  where: SurveyWhereUniqueInput;
  update: SurveyUpdateWithoutSubmitterDataInput;
  create: SurveyCreateWithoutSubmitterInput;
}

export interface DoctorUpdateManyMutationInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  speciality?: Maybe<String>;
  name?: Maybe<String>;
}

export interface PatientCreateInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  birthday: String;
  name: String;
  doctors?: Maybe<DoctorCreateManyWithoutPatientsInput>;
  surveys?: Maybe<SurveyCreateManyWithoutPatientInput>;
}

export interface PatientUpdateInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  birthday?: Maybe<String>;
  name?: Maybe<String>;
  doctors?: Maybe<DoctorUpdateManyWithoutPatientsInput>;
  surveys?: Maybe<SurveyUpdateManyWithoutPatientInput>;
}

export interface PatientUpdateManyMutationInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  birthday?: Maybe<String>;
  name?: Maybe<String>;
}

export interface SurveyCreateInput {
  id?: Maybe<ID_Input>;
  published?: Maybe<Boolean>;
  answered?: Maybe<Boolean>;
  title: String;
  content: String;
  submitter: DoctorCreateOneWithoutSurveysInput;
  patient: PatientCreateOneWithoutSurveysInput;
}

export interface SurveyUpdateInput {
  published?: Maybe<Boolean>;
  answered?: Maybe<Boolean>;
  title?: Maybe<String>;
  content?: Maybe<String>;
  submitter?: Maybe<DoctorUpdateOneRequiredWithoutSurveysInput>;
  patient?: Maybe<PatientUpdateOneRequiredWithoutSurveysInput>;
}

export interface SurveyUpdateManyMutationInput {
  published?: Maybe<Boolean>;
  answered?: Maybe<Boolean>;
  title?: Maybe<String>;
  content?: Maybe<String>;
}

export interface DoctorSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DoctorWhereInput>;
  AND?: Maybe<DoctorSubscriptionWhereInput[] | DoctorSubscriptionWhereInput>;
  OR?: Maybe<DoctorSubscriptionWhereInput[] | DoctorSubscriptionWhereInput>;
  NOT?: Maybe<DoctorSubscriptionWhereInput[] | DoctorSubscriptionWhereInput>;
}

export interface PatientSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PatientWhereInput>;
  AND?: Maybe<PatientSubscriptionWhereInput[] | PatientSubscriptionWhereInput>;
  OR?: Maybe<PatientSubscriptionWhereInput[] | PatientSubscriptionWhereInput>;
  NOT?: Maybe<PatientSubscriptionWhereInput[] | PatientSubscriptionWhereInput>;
}

export interface SurveySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SurveyWhereInput>;
  AND?: Maybe<SurveySubscriptionWhereInput[] | SurveySubscriptionWhereInput>;
  OR?: Maybe<SurveySubscriptionWhereInput[] | SurveySubscriptionWhereInput>;
  NOT?: Maybe<SurveySubscriptionWhereInput[] | SurveySubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Doctor {
  id: ID_Output;
  email: String;
  password: String;
  speciality: String;
  name: String;
}

export interface DoctorPromise extends Promise<Doctor>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  speciality: () => Promise<String>;
  name: () => Promise<String>;
  patients: <T = FragmentableArray<Patient>>(args?: {
    where?: PatientWhereInput;
    orderBy?: PatientOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  surveys: <T = FragmentableArray<Survey>>(args?: {
    where?: SurveyWhereInput;
    orderBy?: SurveyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DoctorSubscription
  extends Promise<AsyncIterator<Doctor>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  speciality: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  patients: <T = Promise<AsyncIterator<PatientSubscription>>>(args?: {
    where?: PatientWhereInput;
    orderBy?: PatientOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  surveys: <T = Promise<AsyncIterator<SurveySubscription>>>(args?: {
    where?: SurveyWhereInput;
    orderBy?: SurveyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DoctorNullablePromise
  extends Promise<Doctor | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  speciality: () => Promise<String>;
  name: () => Promise<String>;
  patients: <T = FragmentableArray<Patient>>(args?: {
    where?: PatientWhereInput;
    orderBy?: PatientOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  surveys: <T = FragmentableArray<Survey>>(args?: {
    where?: SurveyWhereInput;
    orderBy?: SurveyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Patient {
  id: ID_Output;
  email: String;
  password: String;
  birthday: String;
  name: String;
}

export interface PatientPromise extends Promise<Patient>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  birthday: () => Promise<String>;
  name: () => Promise<String>;
  doctors: <T = FragmentableArray<Doctor>>(args?: {
    where?: DoctorWhereInput;
    orderBy?: DoctorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  surveys: <T = FragmentableArray<Survey>>(args?: {
    where?: SurveyWhereInput;
    orderBy?: SurveyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PatientSubscription
  extends Promise<AsyncIterator<Patient>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  birthday: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  doctors: <T = Promise<AsyncIterator<DoctorSubscription>>>(args?: {
    where?: DoctorWhereInput;
    orderBy?: DoctorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  surveys: <T = Promise<AsyncIterator<SurveySubscription>>>(args?: {
    where?: SurveyWhereInput;
    orderBy?: SurveyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PatientNullablePromise
  extends Promise<Patient | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  birthday: () => Promise<String>;
  name: () => Promise<String>;
  doctors: <T = FragmentableArray<Doctor>>(args?: {
    where?: DoctorWhereInput;
    orderBy?: DoctorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  surveys: <T = FragmentableArray<Survey>>(args?: {
    where?: SurveyWhereInput;
    orderBy?: SurveyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Survey {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  published: Boolean;
  answered: Boolean;
  title: String;
  content: String;
}

export interface SurveyPromise extends Promise<Survey>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  published: () => Promise<Boolean>;
  answered: () => Promise<Boolean>;
  title: () => Promise<String>;
  content: () => Promise<String>;
  submitter: <T = DoctorPromise>() => T;
  patient: <T = PatientPromise>() => T;
}

export interface SurveySubscription
  extends Promise<AsyncIterator<Survey>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  published: () => Promise<AsyncIterator<Boolean>>;
  answered: () => Promise<AsyncIterator<Boolean>>;
  title: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  submitter: <T = DoctorSubscription>() => T;
  patient: <T = PatientSubscription>() => T;
}

export interface SurveyNullablePromise
  extends Promise<Survey | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  published: () => Promise<Boolean>;
  answered: () => Promise<Boolean>;
  title: () => Promise<String>;
  content: () => Promise<String>;
  submitter: <T = DoctorPromise>() => T;
  patient: <T = PatientPromise>() => T;
}

export interface DoctorConnection {
  pageInfo: PageInfo;
  edges: DoctorEdge[];
}

export interface DoctorConnectionPromise
  extends Promise<DoctorConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DoctorEdge>>() => T;
  aggregate: <T = AggregateDoctorPromise>() => T;
}

export interface DoctorConnectionSubscription
  extends Promise<AsyncIterator<DoctorConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DoctorEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDoctorSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface DoctorEdge {
  node: Doctor;
  cursor: String;
}

export interface DoctorEdgePromise extends Promise<DoctorEdge>, Fragmentable {
  node: <T = DoctorPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DoctorEdgeSubscription
  extends Promise<AsyncIterator<DoctorEdge>>,
    Fragmentable {
  node: <T = DoctorSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDoctor {
  count: Int;
}

export interface AggregateDoctorPromise
  extends Promise<AggregateDoctor>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDoctorSubscription
  extends Promise<AsyncIterator<AggregateDoctor>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PatientConnection {
  pageInfo: PageInfo;
  edges: PatientEdge[];
}

export interface PatientConnectionPromise
  extends Promise<PatientConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PatientEdge>>() => T;
  aggregate: <T = AggregatePatientPromise>() => T;
}

export interface PatientConnectionSubscription
  extends Promise<AsyncIterator<PatientConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PatientEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePatientSubscription>() => T;
}

export interface PatientEdge {
  node: Patient;
  cursor: String;
}

export interface PatientEdgePromise extends Promise<PatientEdge>, Fragmentable {
  node: <T = PatientPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PatientEdgeSubscription
  extends Promise<AsyncIterator<PatientEdge>>,
    Fragmentable {
  node: <T = PatientSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePatient {
  count: Int;
}

export interface AggregatePatientPromise
  extends Promise<AggregatePatient>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePatientSubscription
  extends Promise<AsyncIterator<AggregatePatient>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SurveyConnection {
  pageInfo: PageInfo;
  edges: SurveyEdge[];
}

export interface SurveyConnectionPromise
  extends Promise<SurveyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SurveyEdge>>() => T;
  aggregate: <T = AggregateSurveyPromise>() => T;
}

export interface SurveyConnectionSubscription
  extends Promise<AsyncIterator<SurveyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SurveyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSurveySubscription>() => T;
}

export interface SurveyEdge {
  node: Survey;
  cursor: String;
}

export interface SurveyEdgePromise extends Promise<SurveyEdge>, Fragmentable {
  node: <T = SurveyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SurveyEdgeSubscription
  extends Promise<AsyncIterator<SurveyEdge>>,
    Fragmentable {
  node: <T = SurveySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSurvey {
  count: Int;
}

export interface AggregateSurveyPromise
  extends Promise<AggregateSurvey>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSurveySubscription
  extends Promise<AsyncIterator<AggregateSurvey>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface DoctorSubscriptionPayload {
  mutation: MutationType;
  node: Doctor;
  updatedFields: String[];
  previousValues: DoctorPreviousValues;
}

export interface DoctorSubscriptionPayloadPromise
  extends Promise<DoctorSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DoctorPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DoctorPreviousValuesPromise>() => T;
}

export interface DoctorSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DoctorSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DoctorSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DoctorPreviousValuesSubscription>() => T;
}

export interface DoctorPreviousValues {
  id: ID_Output;
  email: String;
  password: String;
  speciality: String;
  name: String;
}

export interface DoctorPreviousValuesPromise
  extends Promise<DoctorPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  speciality: () => Promise<String>;
  name: () => Promise<String>;
}

export interface DoctorPreviousValuesSubscription
  extends Promise<AsyncIterator<DoctorPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  speciality: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface PatientSubscriptionPayload {
  mutation: MutationType;
  node: Patient;
  updatedFields: String[];
  previousValues: PatientPreviousValues;
}

export interface PatientSubscriptionPayloadPromise
  extends Promise<PatientSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PatientPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PatientPreviousValuesPromise>() => T;
}

export interface PatientSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PatientSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PatientSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PatientPreviousValuesSubscription>() => T;
}

export interface PatientPreviousValues {
  id: ID_Output;
  email: String;
  password: String;
  birthday: String;
  name: String;
}

export interface PatientPreviousValuesPromise
  extends Promise<PatientPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  birthday: () => Promise<String>;
  name: () => Promise<String>;
}

export interface PatientPreviousValuesSubscription
  extends Promise<AsyncIterator<PatientPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  birthday: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface SurveySubscriptionPayload {
  mutation: MutationType;
  node: Survey;
  updatedFields: String[];
  previousValues: SurveyPreviousValues;
}

export interface SurveySubscriptionPayloadPromise
  extends Promise<SurveySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SurveyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SurveyPreviousValuesPromise>() => T;
}

export interface SurveySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SurveySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SurveySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SurveyPreviousValuesSubscription>() => T;
}

export interface SurveyPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  published: Boolean;
  answered: Boolean;
  title: String;
  content: String;
}

export interface SurveyPreviousValuesPromise
  extends Promise<SurveyPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  published: () => Promise<Boolean>;
  answered: () => Promise<Boolean>;
  title: () => Promise<String>;
  content: () => Promise<String>;
}

export interface SurveyPreviousValuesSubscription
  extends Promise<AsyncIterator<SurveyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  published: () => Promise<AsyncIterator<Boolean>>;
  answered: () => Promise<AsyncIterator<Boolean>>;
  title: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Doctor",
    embedded: false
  },
  {
    name: "Patient",
    embedded: false
  },
  {
    name: "Survey",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://localhost:4466`
});
export const prisma = new Prisma();
