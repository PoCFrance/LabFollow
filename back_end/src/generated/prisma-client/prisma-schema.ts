// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateDoctor {
  count: Int!
}

type AggregatePatient {
  count: Int!
}

type AggregateSurvey {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar DateTime

type Doctor {
  id: ID!
  email: String!
  password: String!
  speciality: String!
  name: String!
  patients(where: PatientWhereInput, orderBy: PatientOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Patient!]
  surveys(where: SurveyWhereInput, orderBy: SurveyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Survey!]
}

type DoctorConnection {
  pageInfo: PageInfo!
  edges: [DoctorEdge]!
  aggregate: AggregateDoctor!
}

input DoctorCreateInput {
  id: ID
  email: String!
  password: String!
  speciality: String!
  name: String!
  patients: PatientCreateManyWithoutDoctorsInput
  surveys: SurveyCreateManyWithoutSubmitterInput
}

input DoctorCreateManyWithoutPatientsInput {
  create: [DoctorCreateWithoutPatientsInput!]
  connect: [DoctorWhereUniqueInput!]
}

input DoctorCreateOneWithoutSurveysInput {
  create: DoctorCreateWithoutSurveysInput
  connect: DoctorWhereUniqueInput
}

input DoctorCreateWithoutPatientsInput {
  id: ID
  email: String!
  password: String!
  speciality: String!
  name: String!
  surveys: SurveyCreateManyWithoutSubmitterInput
}

input DoctorCreateWithoutSurveysInput {
  id: ID
  email: String!
  password: String!
  speciality: String!
  name: String!
  patients: PatientCreateManyWithoutDoctorsInput
}

type DoctorEdge {
  node: Doctor!
  cursor: String!
}

enum DoctorOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  speciality_ASC
  speciality_DESC
  name_ASC
  name_DESC
}

type DoctorPreviousValues {
  id: ID!
  email: String!
  password: String!
  speciality: String!
  name: String!
}

input DoctorScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  speciality: String
  speciality_not: String
  speciality_in: [String!]
  speciality_not_in: [String!]
  speciality_lt: String
  speciality_lte: String
  speciality_gt: String
  speciality_gte: String
  speciality_contains: String
  speciality_not_contains: String
  speciality_starts_with: String
  speciality_not_starts_with: String
  speciality_ends_with: String
  speciality_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [DoctorScalarWhereInput!]
  OR: [DoctorScalarWhereInput!]
  NOT: [DoctorScalarWhereInput!]
}

type DoctorSubscriptionPayload {
  mutation: MutationType!
  node: Doctor
  updatedFields: [String!]
  previousValues: DoctorPreviousValues
}

input DoctorSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DoctorWhereInput
  AND: [DoctorSubscriptionWhereInput!]
  OR: [DoctorSubscriptionWhereInput!]
  NOT: [DoctorSubscriptionWhereInput!]
}

input DoctorUpdateInput {
  email: String
  password: String
  speciality: String
  name: String
  patients: PatientUpdateManyWithoutDoctorsInput
  surveys: SurveyUpdateManyWithoutSubmitterInput
}

input DoctorUpdateManyDataInput {
  email: String
  password: String
  speciality: String
  name: String
}

input DoctorUpdateManyMutationInput {
  email: String
  password: String
  speciality: String
  name: String
}

input DoctorUpdateManyWithoutPatientsInput {
  create: [DoctorCreateWithoutPatientsInput!]
  delete: [DoctorWhereUniqueInput!]
  connect: [DoctorWhereUniqueInput!]
  set: [DoctorWhereUniqueInput!]
  disconnect: [DoctorWhereUniqueInput!]
  update: [DoctorUpdateWithWhereUniqueWithoutPatientsInput!]
  upsert: [DoctorUpsertWithWhereUniqueWithoutPatientsInput!]
  deleteMany: [DoctorScalarWhereInput!]
  updateMany: [DoctorUpdateManyWithWhereNestedInput!]
}

input DoctorUpdateManyWithWhereNestedInput {
  where: DoctorScalarWhereInput!
  data: DoctorUpdateManyDataInput!
}

input DoctorUpdateOneRequiredWithoutSurveysInput {
  create: DoctorCreateWithoutSurveysInput
  update: DoctorUpdateWithoutSurveysDataInput
  upsert: DoctorUpsertWithoutSurveysInput
  connect: DoctorWhereUniqueInput
}

input DoctorUpdateWithoutPatientsDataInput {
  email: String
  password: String
  speciality: String
  name: String
  surveys: SurveyUpdateManyWithoutSubmitterInput
}

input DoctorUpdateWithoutSurveysDataInput {
  email: String
  password: String
  speciality: String
  name: String
  patients: PatientUpdateManyWithoutDoctorsInput
}

input DoctorUpdateWithWhereUniqueWithoutPatientsInput {
  where: DoctorWhereUniqueInput!
  data: DoctorUpdateWithoutPatientsDataInput!
}

input DoctorUpsertWithoutSurveysInput {
  update: DoctorUpdateWithoutSurveysDataInput!
  create: DoctorCreateWithoutSurveysInput!
}

input DoctorUpsertWithWhereUniqueWithoutPatientsInput {
  where: DoctorWhereUniqueInput!
  update: DoctorUpdateWithoutPatientsDataInput!
  create: DoctorCreateWithoutPatientsInput!
}

input DoctorWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  speciality: String
  speciality_not: String
  speciality_in: [String!]
  speciality_not_in: [String!]
  speciality_lt: String
  speciality_lte: String
  speciality_gt: String
  speciality_gte: String
  speciality_contains: String
  speciality_not_contains: String
  speciality_starts_with: String
  speciality_not_starts_with: String
  speciality_ends_with: String
  speciality_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  patients_every: PatientWhereInput
  patients_some: PatientWhereInput
  patients_none: PatientWhereInput
  surveys_every: SurveyWhereInput
  surveys_some: SurveyWhereInput
  surveys_none: SurveyWhereInput
  AND: [DoctorWhereInput!]
  OR: [DoctorWhereInput!]
  NOT: [DoctorWhereInput!]
}

input DoctorWhereUniqueInput {
  id: ID
  email: String
}

scalar Long

type Mutation {
  createDoctor(data: DoctorCreateInput!): Doctor!
  updateDoctor(data: DoctorUpdateInput!, where: DoctorWhereUniqueInput!): Doctor
  updateManyDoctors(data: DoctorUpdateManyMutationInput!, where: DoctorWhereInput): BatchPayload!
  upsertDoctor(where: DoctorWhereUniqueInput!, create: DoctorCreateInput!, update: DoctorUpdateInput!): Doctor!
  deleteDoctor(where: DoctorWhereUniqueInput!): Doctor
  deleteManyDoctors(where: DoctorWhereInput): BatchPayload!
  createPatient(data: PatientCreateInput!): Patient!
  updatePatient(data: PatientUpdateInput!, where: PatientWhereUniqueInput!): Patient
  updateManyPatients(data: PatientUpdateManyMutationInput!, where: PatientWhereInput): BatchPayload!
  upsertPatient(where: PatientWhereUniqueInput!, create: PatientCreateInput!, update: PatientUpdateInput!): Patient!
  deletePatient(where: PatientWhereUniqueInput!): Patient
  deleteManyPatients(where: PatientWhereInput): BatchPayload!
  createSurvey(data: SurveyCreateInput!): Survey!
  updateSurvey(data: SurveyUpdateInput!, where: SurveyWhereUniqueInput!): Survey
  updateManySurveys(data: SurveyUpdateManyMutationInput!, where: SurveyWhereInput): BatchPayload!
  upsertSurvey(where: SurveyWhereUniqueInput!, create: SurveyCreateInput!, update: SurveyUpdateInput!): Survey!
  deleteSurvey(where: SurveyWhereUniqueInput!): Survey
  deleteManySurveys(where: SurveyWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Patient {
  id: ID!
  email: String!
  password: String!
  birthday: String!
  name: String!
  doctors(where: DoctorWhereInput, orderBy: DoctorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Doctor!]
  surveys(where: SurveyWhereInput, orderBy: SurveyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Survey!]
}

type PatientConnection {
  pageInfo: PageInfo!
  edges: [PatientEdge]!
  aggregate: AggregatePatient!
}

input PatientCreateInput {
  id: ID
  email: String!
  password: String!
  birthday: String!
  name: String!
  doctors: DoctorCreateManyWithoutPatientsInput
  surveys: SurveyCreateManyWithoutPatientInput
}

input PatientCreateManyWithoutDoctorsInput {
  create: [PatientCreateWithoutDoctorsInput!]
  connect: [PatientWhereUniqueInput!]
}

input PatientCreateOneWithoutSurveysInput {
  create: PatientCreateWithoutSurveysInput
  connect: PatientWhereUniqueInput
}

input PatientCreateWithoutDoctorsInput {
  id: ID
  email: String!
  password: String!
  birthday: String!
  name: String!
  surveys: SurveyCreateManyWithoutPatientInput
}

input PatientCreateWithoutSurveysInput {
  id: ID
  email: String!
  password: String!
  birthday: String!
  name: String!
  doctors: DoctorCreateManyWithoutPatientsInput
}

type PatientEdge {
  node: Patient!
  cursor: String!
}

enum PatientOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  birthday_ASC
  birthday_DESC
  name_ASC
  name_DESC
}

type PatientPreviousValues {
  id: ID!
  email: String!
  password: String!
  birthday: String!
  name: String!
}

input PatientScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  birthday: String
  birthday_not: String
  birthday_in: [String!]
  birthday_not_in: [String!]
  birthday_lt: String
  birthday_lte: String
  birthday_gt: String
  birthday_gte: String
  birthday_contains: String
  birthday_not_contains: String
  birthday_starts_with: String
  birthday_not_starts_with: String
  birthday_ends_with: String
  birthday_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [PatientScalarWhereInput!]
  OR: [PatientScalarWhereInput!]
  NOT: [PatientScalarWhereInput!]
}

type PatientSubscriptionPayload {
  mutation: MutationType!
  node: Patient
  updatedFields: [String!]
  previousValues: PatientPreviousValues
}

input PatientSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PatientWhereInput
  AND: [PatientSubscriptionWhereInput!]
  OR: [PatientSubscriptionWhereInput!]
  NOT: [PatientSubscriptionWhereInput!]
}

input PatientUpdateInput {
  email: String
  password: String
  birthday: String
  name: String
  doctors: DoctorUpdateManyWithoutPatientsInput
  surveys: SurveyUpdateManyWithoutPatientInput
}

input PatientUpdateManyDataInput {
  email: String
  password: String
  birthday: String
  name: String
}

input PatientUpdateManyMutationInput {
  email: String
  password: String
  birthday: String
  name: String
}

input PatientUpdateManyWithoutDoctorsInput {
  create: [PatientCreateWithoutDoctorsInput!]
  delete: [PatientWhereUniqueInput!]
  connect: [PatientWhereUniqueInput!]
  set: [PatientWhereUniqueInput!]
  disconnect: [PatientWhereUniqueInput!]
  update: [PatientUpdateWithWhereUniqueWithoutDoctorsInput!]
  upsert: [PatientUpsertWithWhereUniqueWithoutDoctorsInput!]
  deleteMany: [PatientScalarWhereInput!]
  updateMany: [PatientUpdateManyWithWhereNestedInput!]
}

input PatientUpdateManyWithWhereNestedInput {
  where: PatientScalarWhereInput!
  data: PatientUpdateManyDataInput!
}

input PatientUpdateOneRequiredWithoutSurveysInput {
  create: PatientCreateWithoutSurveysInput
  update: PatientUpdateWithoutSurveysDataInput
  upsert: PatientUpsertWithoutSurveysInput
  connect: PatientWhereUniqueInput
}

input PatientUpdateWithoutDoctorsDataInput {
  email: String
  password: String
  birthday: String
  name: String
  surveys: SurveyUpdateManyWithoutPatientInput
}

input PatientUpdateWithoutSurveysDataInput {
  email: String
  password: String
  birthday: String
  name: String
  doctors: DoctorUpdateManyWithoutPatientsInput
}

input PatientUpdateWithWhereUniqueWithoutDoctorsInput {
  where: PatientWhereUniqueInput!
  data: PatientUpdateWithoutDoctorsDataInput!
}

input PatientUpsertWithoutSurveysInput {
  update: PatientUpdateWithoutSurveysDataInput!
  create: PatientCreateWithoutSurveysInput!
}

input PatientUpsertWithWhereUniqueWithoutDoctorsInput {
  where: PatientWhereUniqueInput!
  update: PatientUpdateWithoutDoctorsDataInput!
  create: PatientCreateWithoutDoctorsInput!
}

input PatientWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  birthday: String
  birthday_not: String
  birthday_in: [String!]
  birthday_not_in: [String!]
  birthday_lt: String
  birthday_lte: String
  birthday_gt: String
  birthday_gte: String
  birthday_contains: String
  birthday_not_contains: String
  birthday_starts_with: String
  birthday_not_starts_with: String
  birthday_ends_with: String
  birthday_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  doctors_every: DoctorWhereInput
  doctors_some: DoctorWhereInput
  doctors_none: DoctorWhereInput
  surveys_every: SurveyWhereInput
  surveys_some: SurveyWhereInput
  surveys_none: SurveyWhereInput
  AND: [PatientWhereInput!]
  OR: [PatientWhereInput!]
  NOT: [PatientWhereInput!]
}

input PatientWhereUniqueInput {
  id: ID
  email: String
}

type Query {
  doctor(where: DoctorWhereUniqueInput!): Doctor
  doctors(where: DoctorWhereInput, orderBy: DoctorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Doctor]!
  doctorsConnection(where: DoctorWhereInput, orderBy: DoctorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DoctorConnection!
  patient(where: PatientWhereUniqueInput!): Patient
  patients(where: PatientWhereInput, orderBy: PatientOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Patient]!
  patientsConnection(where: PatientWhereInput, orderBy: PatientOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PatientConnection!
  survey(where: SurveyWhereUniqueInput!): Survey
  surveys(where: SurveyWhereInput, orderBy: SurveyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Survey]!
  surveysConnection(where: SurveyWhereInput, orderBy: SurveyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SurveyConnection!
  node(id: ID!): Node
}

type Subscription {
  doctor(where: DoctorSubscriptionWhereInput): DoctorSubscriptionPayload
  patient(where: PatientSubscriptionWhereInput): PatientSubscriptionPayload
  survey(where: SurveySubscriptionWhereInput): SurveySubscriptionPayload
}

type Survey {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  published: Boolean!
  answered: Boolean!
  title: String!
  content: String!
  submitter: Doctor!
  patient: Patient!
}

type SurveyConnection {
  pageInfo: PageInfo!
  edges: [SurveyEdge]!
  aggregate: AggregateSurvey!
}

input SurveyCreateInput {
  id: ID
  published: Boolean
  answered: Boolean
  title: String!
  content: String!
  submitter: DoctorCreateOneWithoutSurveysInput!
  patient: PatientCreateOneWithoutSurveysInput!
}

input SurveyCreateManyWithoutPatientInput {
  create: [SurveyCreateWithoutPatientInput!]
  connect: [SurveyWhereUniqueInput!]
}

input SurveyCreateManyWithoutSubmitterInput {
  create: [SurveyCreateWithoutSubmitterInput!]
  connect: [SurveyWhereUniqueInput!]
}

input SurveyCreateWithoutPatientInput {
  id: ID
  published: Boolean
  answered: Boolean
  title: String!
  content: String!
  submitter: DoctorCreateOneWithoutSurveysInput!
}

input SurveyCreateWithoutSubmitterInput {
  id: ID
  published: Boolean
  answered: Boolean
  title: String!
  content: String!
  patient: PatientCreateOneWithoutSurveysInput!
}

type SurveyEdge {
  node: Survey!
  cursor: String!
}

enum SurveyOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  published_ASC
  published_DESC
  answered_ASC
  answered_DESC
  title_ASC
  title_DESC
  content_ASC
  content_DESC
}

type SurveyPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  published: Boolean!
  answered: Boolean!
  title: String!
  content: String!
}

input SurveyScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  published: Boolean
  published_not: Boolean
  answered: Boolean
  answered_not: Boolean
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  AND: [SurveyScalarWhereInput!]
  OR: [SurveyScalarWhereInput!]
  NOT: [SurveyScalarWhereInput!]
}

type SurveySubscriptionPayload {
  mutation: MutationType!
  node: Survey
  updatedFields: [String!]
  previousValues: SurveyPreviousValues
}

input SurveySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SurveyWhereInput
  AND: [SurveySubscriptionWhereInput!]
  OR: [SurveySubscriptionWhereInput!]
  NOT: [SurveySubscriptionWhereInput!]
}

input SurveyUpdateInput {
  published: Boolean
  answered: Boolean
  title: String
  content: String
  submitter: DoctorUpdateOneRequiredWithoutSurveysInput
  patient: PatientUpdateOneRequiredWithoutSurveysInput
}

input SurveyUpdateManyDataInput {
  published: Boolean
  answered: Boolean
  title: String
  content: String
}

input SurveyUpdateManyMutationInput {
  published: Boolean
  answered: Boolean
  title: String
  content: String
}

input SurveyUpdateManyWithoutPatientInput {
  create: [SurveyCreateWithoutPatientInput!]
  delete: [SurveyWhereUniqueInput!]
  connect: [SurveyWhereUniqueInput!]
  set: [SurveyWhereUniqueInput!]
  disconnect: [SurveyWhereUniqueInput!]
  update: [SurveyUpdateWithWhereUniqueWithoutPatientInput!]
  upsert: [SurveyUpsertWithWhereUniqueWithoutPatientInput!]
  deleteMany: [SurveyScalarWhereInput!]
  updateMany: [SurveyUpdateManyWithWhereNestedInput!]
}

input SurveyUpdateManyWithoutSubmitterInput {
  create: [SurveyCreateWithoutSubmitterInput!]
  delete: [SurveyWhereUniqueInput!]
  connect: [SurveyWhereUniqueInput!]
  set: [SurveyWhereUniqueInput!]
  disconnect: [SurveyWhereUniqueInput!]
  update: [SurveyUpdateWithWhereUniqueWithoutSubmitterInput!]
  upsert: [SurveyUpsertWithWhereUniqueWithoutSubmitterInput!]
  deleteMany: [SurveyScalarWhereInput!]
  updateMany: [SurveyUpdateManyWithWhereNestedInput!]
}

input SurveyUpdateManyWithWhereNestedInput {
  where: SurveyScalarWhereInput!
  data: SurveyUpdateManyDataInput!
}

input SurveyUpdateWithoutPatientDataInput {
  published: Boolean
  answered: Boolean
  title: String
  content: String
  submitter: DoctorUpdateOneRequiredWithoutSurveysInput
}

input SurveyUpdateWithoutSubmitterDataInput {
  published: Boolean
  answered: Boolean
  title: String
  content: String
  patient: PatientUpdateOneRequiredWithoutSurveysInput
}

input SurveyUpdateWithWhereUniqueWithoutPatientInput {
  where: SurveyWhereUniqueInput!
  data: SurveyUpdateWithoutPatientDataInput!
}

input SurveyUpdateWithWhereUniqueWithoutSubmitterInput {
  where: SurveyWhereUniqueInput!
  data: SurveyUpdateWithoutSubmitterDataInput!
}

input SurveyUpsertWithWhereUniqueWithoutPatientInput {
  where: SurveyWhereUniqueInput!
  update: SurveyUpdateWithoutPatientDataInput!
  create: SurveyCreateWithoutPatientInput!
}

input SurveyUpsertWithWhereUniqueWithoutSubmitterInput {
  where: SurveyWhereUniqueInput!
  update: SurveyUpdateWithoutSubmitterDataInput!
  create: SurveyCreateWithoutSubmitterInput!
}

input SurveyWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  published: Boolean
  published_not: Boolean
  answered: Boolean
  answered_not: Boolean
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  submitter: DoctorWhereInput
  patient: PatientWhereInput
  AND: [SurveyWhereInput!]
  OR: [SurveyWhereInput!]
  NOT: [SurveyWhereInput!]
}

input SurveyWhereUniqueInput {
  id: ID
}
`